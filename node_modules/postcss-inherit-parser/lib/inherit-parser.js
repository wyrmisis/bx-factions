'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _parser = require('postcss/lib/parser');

var _parser2 = _interopRequireDefault(_parser);

var _tokenize = require('postcss/lib/tokenize');

var _tokenize2 = _interopRequireDefault(_tokenize);

var _declaration = require('postcss/lib/declaration');

var _declaration2 = _interopRequireDefault(_declaration);

var _inheritPropertySyntax = require('./inherit-property-syntax');

var _inheritPropertySyntax2 = _interopRequireDefault(_inheritPropertySyntax);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 *  InheritParser Class extends default PostCSS Parser
 */
var InheritParser = function (_Parser) {
  _inherits(InheritParser, _Parser);

  /**
   *  Public: intiates InheritParser Class and loads options
   *
   *  * `input` css source {String}
   *  * `opts` (optional) {Object} the `propertyRegExp` property will change inherit syntax.
   *
   *  ## Example
   *
   *     export default function inheritParse(css, opts) {
   *       const input = new Input(css, opts);
   *       const parser = new InheritParser(input, opts);
   *       parser.tokenize();
   *       parser.loop();
   *       return parser.root;
   *     }
   */
  function InheritParser(input) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, InheritParser);

    var _this = _possibleConstructorReturn(this, (InheritParser.__proto__ || Object.getPrototypeOf(InheritParser)).call(this, input));

    _this.propertyRegExp = (0, _inheritPropertySyntax2.default)(opts);
    return _this;
  }
  /**
   *  Public: uses default postcss tokenize method.
   *
   *  ## Example
   *
   *  Used as part of the postcss parser
   *
   *     parser.createTokenizer();
   */


  _createClass(InheritParser, [{
    key: 'createTokenizer',
    value: function createTokenizer() {
      this.tokenizer = (0, _tokenize2.default)(this.input, {
        ignoreErrors: true
      });
    }
    /**
     *  Public: overrides default parser `decl` method; parses tokenized css declarations
     *
     *  * `tokens` {Array} of tokens from `tokenize` method.
     *
     *  ## Example
     *
     *  Really only used by other methods in the parser.
     *
     *    this.decl(this.tokens.slice(start, this.pos + 1));
     *
     *  Returns {Declaration}
     */

  }, {
    key: 'decl',
    value: function decl(tokens) {
      var node = new _declaration2.default();
      this.init(node);

      var last = tokens[tokens.length - 1];
      if (last[0] === ';') {
        this.semicolon = true;
        tokens.pop();
      }
      if (last[4]) {
        node.source.end = {
          line: last[4],
          column: last[5]
        };
      } else {
        node.source.end = {
          line: last[2],
          column: last[3]
        };
      }

      while (tokens[0][0] !== 'word') {
        node.raws.before += tokens.shift()[1];
      }
      node.source.start = {
        line: tokens[0][2],
        column: tokens[0][3]
      };

      node.prop = '';
      while (tokens.length) {
        var type = tokens[0][0];
        if (type === ':' || type === 'space' || type === 'comment') {
          break;
        }
        node.prop += tokens.shift()[1];
      }

      node.raws.between = '';

      var token = void 0;
      while (tokens.length) {
        token = tokens.shift();

        if (token[0] === ':') {
          node.raws.between += token[1];
          break;
        } else {
          node.raws.between += token[1];
        }
      }

      if (node.prop[0] === '_' || node.prop[0] === '*') {
        node.raws.before += node.prop[0];
        node.prop = node.prop.slice(1);
      }
      node.raws.between += this.spacesAndCommentsFromStart(tokens);
      this.precheckMissedSemicolon(tokens);

      for (var i = tokens.length - 1; i > 0; i--) {
        token = tokens[i];
        if (token[1].toLowerCase() === '!important') {
          node.important = true;
          var string = this.stringFrom(tokens, i);
          string = this.spacesFromEnd(tokens) + string;
          if (string !== ' !important') node.raws.important = string;
          break;
        } else if (token[1].toLowerCase() === 'important') {
          var cache = tokens.slice(0);
          var str = '';
          for (var j = i; j > 0; j--) {
            var _type = cache[j][0];
            if (str.trim().indexOf('!') === 0 && _type !== 'space') {
              break;
            }
            str = cache.pop()[1] + str;
          }
          if (str.trim().indexOf('!') === 0) {
            node.important = true;
            node.raws.important = str;
            // eslint-disable-next-line no-param-reassign
            tokens = cache;
          }
        }

        if (token[0] !== 'space' && token[0] !== 'comment') {
          break;
        }
      }

      this.raw(node, 'value', tokens);

      if (node.value.indexOf(':') !== -1) this.checkMissedSemicolon(tokens, node.prop);
    }
    /**
     *  Public: overrides default parser `checkMissedSemicolon` method.
     *  Checks for 2 colons without a semi colon inbetween.
     *  Ignored if property is the inherit keyword.
     *
     *  * `tokens` {Array} of tokens from `tokenize` method.
     *  * `prop` {String} of css property
     *
     *  ## Example
     *
     *  Meant to only be used by other parser methods.
     *
     *     if (node.value.indexOf(':') !== -1) this.checkMissedSemicolon(tokens, node.prop);
     *
     *  Throws error if it detects missed semicolon
     */

  }, {
    key: 'checkMissedSemicolon',
    value: function checkMissedSemicolon(tokens, prop) {
      if (this.propertyRegExp.test(prop)) return;
      var colon = this.colon(tokens);
      if (colon === false) return;

      var founded = 0;
      var token = void 0;
      for (var j = colon - 1; j >= 0; j--) {
        token = tokens[j];
        if (token[0] !== 'space') {
          founded += 1;
          if (founded === 2) break;
        }
      }
      throw this.input.error('Missed semicolon', token[2], token[3]);
    }
  }]);

  return InheritParser;
}(_parser2.default);

exports.default = InheritParser;
module.exports = exports['default'];